
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Package solver &#8212; IBOAT MCTS 1.0.0 documentation</title>
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Package isochrones" href="isochrones.html" />
    <link rel="prev" title="Package model" href="model.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="package-solver">
<h1>Package solver<a class="headerlink" href="#package-solver" title="Permalink to this headline">¶</a></h1>
<div class="section" id="module-master">
<span id="master"></span><h2>master<a class="headerlink" href="#module-master" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="master.MasterTree">
<em class="property">class </em><code class="descclassname">master.</code><code class="descname">MasterTree</code><span class="sig-paren">(</span><em>sims</em>, <em>destination</em>, <em>nodes={}</em>, <em>proba=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Tree that stores the final result of a MCTS parallel search on multiple scenarios. Is not the direct
output of the search but already incorporates some post-processing.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>nodes</strong> (<em>dict</em>) – dictionary containing <a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">master_node.MasterNode</span></code></a>, the keys are their corresponding hash</li>
<li><strong>probability</strong> (<em>numpy.array</em>) – array containing the probability of each scenario</li>
<li><strong>Simulators</strong> (<em>list</em>) – List of the :class:<a href="#id1"><span class="problematic" id="id2">`</span></a>simulatorTLKT.Simulator`objects used during the search</li>
<li><strong>numScenarios</strong> (<em>int</em>) – Number of scenarios</li>
<li><strong>destination</strong> (<em>list</em>) – Destination state [lat, long]</li>
<li><strong>best_policy</strong> (<em>dict</em>) – Dictionary of list of actions. Key of the dictionary is the scenario id.
Key -1 is for the average policy. The list is the sequel of action.</li>
<li><strong>best_global_nodes_policy</strong> (<em>dict</em>) – Dictionary of list of <a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">master_node.MasterNode</span></code></a> encountered during the best
policy of one scenario. The Key of the dictionary is the scenario id.
Key -1 is for the average policy.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="master.MasterTree.get_best_child">
<code class="descname">get_best_child</code><span class="sig-paren">(</span><em>node</em>, <em>idscenario=-1</em>, <em>verbose=False</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.get_best_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Compares the children of a node based on their rewards and return the best one.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> (<a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><em>MasterNode</em></a>) – the parent <a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">master_node.MasterNode</span></code></a></li>
<li><strong>idscenario</strong> (<em>int</em>) – id of the considered scenario. If default (-1), the method returns the best child
for the global tree</li>
<li><strong>verbose</strong> (<em>bool</em>) – If True, prints the best reward and the best action.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple: (the best child, the action taken to go from the node to its best child)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.get_best_policy">
<code class="descname">get_best_policy</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.get_best_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the best policy for each scenario and the global best policy. And add it to the object.</p>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.get_points">
<code class="descname">get_points</code><span class="sig-paren">(</span><em>node</em>, <em>points</em>, <em>probability</em>, <em>coordinate=(0</em>, <em>0)</em>, <em>idscenario=-1</em>, <em>objective='depth'</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.get_points" title="Permalink to this definition">¶</a></dt>
<dd><p>Recursive function used in <a class="reference internal" href="#master.MasterTree.plot_tree" title="master.MasterTree.plot_tree"><code class="xref py py-func docutils literal"><span class="pre">plot_tree()</span></code></a> and <code class="xref py py-func docutils literal"><span class="pre">plot_tree_colored()</span></code> to compute the coordinates        of a node in the plot and other node properties depending on the objective parameter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> – a <a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">master_node.MasterNode</span></code></a> object</li>
<li><strong>points</strong> (<em>list</em>) – the previous list of points</li>
<li><strong>probability</strong> (<em>np.array</em>) – probability of each scenario</li>
<li><strong>coordinate</strong> (<em>tuple</em>) – coordinates of the previous point</li>
<li><strong>idscenario</strong> (<em>int</em>) – id of the corresponding worker tree to be plot. If -1 (default),
the global tree is plotted.</li>
<li><strong>objective</strong> (<em>string</em>) – “uct” to compute exploration, explotation and utility. “depth” to compute the
depth of each node.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the expanded list of points, a point being a tuple</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.get_utility">
<code class="descname">get_utility</code><span class="sig-paren">(</span><em>node</em>, <em>idscenario</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.get_utility" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the utility of an node as the sum of the exploration and exploitation term. It done either
for a given scenario or as the weighted mean over all the scenario (global utility) if idscenario = -1</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> – The <a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">master_node.MasterNode</span></code></a> whose utility we want to compute</li>
<li><strong>idscenario</strong> – scenario’s id</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">exploitation term, exploration term</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float, float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.guess_reward">
<code class="descname">guess_reward</code><span class="sig-paren">(</span><em>node</em>, <em>idscenario</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.guess_reward" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimates the reward of an unexplored node (for a given scenario)
as the lower reward such that its father node would be expanded next.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> – The <a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">master_node.MasterNode</span></code></a> whose reward we want to estimate</li>
<li><strong>idscenario</strong> (<em>int</em>) – scenario’s id</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">The estimated reward</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">float</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="classmethod">
<dt id="master.MasterTree.load_tree">
<em class="property">classmethod </em><code class="descname">load_tree</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.load_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Load a master tree (object) from the data Folder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – Name of the file.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.plot_best_policy">
<code class="descname">plot_best_policy</code><span class="sig-paren">(</span><em>idscenario=-1</em>, <em>number_subplots=1</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.plot_best_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a representation of a tree and its best policy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>grey</strong> (<em>boolean</em>) – if True, each node/branch are plot with a color (grey scale) depending of the depth of the node</li>
<li><strong>idscenario</strong> (<em>int</em>) – id of the corresponding worker tree to be plot. If -1 (default), the global tree is plotted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (fig, ax) of the current plot</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.plot_hist_best_policy">
<code class="descname">plot_hist_best_policy</code><span class="sig-paren">(</span><em>idscenario=-1</em>, <em>interactive=False</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.plot_hist_best_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the best policy as in <a class="reference internal" href="#master.MasterTree.plot_best_policy" title="master.MasterTree.plot_best_policy"><code class="xref py py-meth docutils literal"><span class="pre">plot_best_policy()</span></code></a>, with the histogram of the best action at each node         (<a class="reference external" href="https://matplotlib.org/api/animation_api.html">Animation</a>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>idscenario</strong> (<em>int</em>) – id of the corresponding worker tree to be plot. If -1 (default), the global tree is plotted.</li>
<li><strong>interactive</strong> (<em>bool</em>) – if True the plot is not an animation but can be browsed step by step</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">the <a class="reference external" href="https://matplotlib.org/api/figure_api.html">figure</a> of the current plot</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.plot_tree">
<code class="descname">plot_tree</code><span class="sig-paren">(</span><em>idscenario=-1</em>, <em>number_subplots=1</em>, <em>gray=True</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.plot_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot a 2D representation of a tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>gray</strong> (<em>boolean</em>) – if True, each node/branch are plot with a color (grey scale) depending of the depth of the node</li>
<li><strong>idscenario</strong> (<em>int</em>) – id of the corresponding worker tree to be plot. If -1 (default), the global tree is plotted.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple (fig, ax) of the current plot</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.plot_tree_uct">
<code class="descname">plot_tree_uct</code><span class="sig-paren">(</span><em>idscenario=-1</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.plot_tree_uct" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the tree 3 times: for the first one the colormap represents the sum of exploitation and exploration for each node
, the second one represents the exploitation and the third one the exploration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>idscenario</strong> (<em>int</em>) – id of the corresponding worker tree to be plot. If -1 (default), the global tree is plotted.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">A tuple (fig, ax) of the current plot</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master.MasterTree.save_tree">
<code class="descname">save_tree</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="headerlink" href="#master.MasterTree.save_tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Save the master tree (object) in the data Folder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>name</strong> – Name of the file.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-worker">
<span id="worker"></span><h2>worker<a class="headerlink" href="#module-worker" title="Permalink to this headline">¶</a></h2>
<p>Created on Wed May 31 10:06:46 2017</p>
<p>&#64;author: paul</p>
<dl class="class">
<dt id="worker.Node">
<em class="property">class </em><code class="descclassname">worker.</code><code class="descname">Node</code><span class="sig-paren">(</span><em>state=None</em>, <em>parent=None</em>, <em>origins=[]</em>, <em>children=[]</em>, <em>depth=0</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Node" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Node of a <a class="reference internal" href="#worker.Tree" title="worker.Tree"><code class="xref py py-class docutils literal"><span class="pre">worker.Tree</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>state</strong> (<em>tuple</em>) – Only for the root Node: initial state (time, lat, lon), None for other node.</li>
<li><strong>parent</strong> (<a class="reference internal" href="#worker.Node" title="worker.Node"><em>worker.Node</em></a>) – Reference to the parent of this node.</li>
<li><strong>origins</strong> (<em>list</em>) – sequel of actions taken from to root node to this node.</li>
<li><strong>children</strong> (<em>list</em>) – Child nodes of this node.</li>
<li><strong>actions</strong> (<em>list</em>) – Remaining actions available (not expanded) from this node in random order.</li>
<li><strong>Values</strong> (<em>numpy.array</em>) – Array of <code class="xref py py-class docutils literal"><span class="pre">utils.Hist</span></code> to save the rewards. Its size is the number of possible actions.</li>
<li><strong>depth</strong> (<em>int</em>) – Depth of the node in the Tree.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="worker.Node.back_up">
<code class="descname">back_up</code><span class="sig-paren">(</span><em>reward</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Node.back_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Propagates the reward through the Tree, starting from this <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>reward</strong> (<em>float</em>) – The reward corresponding to the expansion of this <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="worker.Node.get_uct">
<code class="descname">get_uct</code><span class="sig-paren">(</span><em>num_parent</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Node.get_uct" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the uct values of this <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a> (combination of exploration and exploitation)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>num_parent</strong> (<em>int</em>) – Number of times the parent of the <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a> has been explored.</td>
</tr>
<tr class="field-even field"><th class="field-name">Return float:</th><td class="field-body">The uct value.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="worker.Node.is_fully_expanded">
<code class="descname">is_fully_expanded</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#worker.Node.is_fully_expanded" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns True if this <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a> is fully expanded (if there is not remaining actions)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Return boolean:</th><td class="field-body">True if fully expanded, False otherwise.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="worker.Tree">
<em class="property">class </em><code class="descclassname">worker.</code><code class="descname">Tree</code><span class="sig-paren">(</span><em>workerid</em>, <em>nscenario</em>, <em>probability=[]</em>, <em>ite=0</em>, <em>budget=1000</em>, <em>simulator=None</em>, <em>destination=[]</em>, <em>TimeMin=0</em>, <em>buffer=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A tree which represents a MCTS on one scenario.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>id</strong> (<em>int</em>) – Id of the tree, corresponding to the id scenario.</li>
<li><strong>ite</strong> (<em>int</em>) – Current number of iterations done.</li>
<li><strong>budget</strong> (<em>int</em>) – Max. number of iterations</li>
<li><strong>simulator</strong> (<a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><em>Simulator</em></a>) – The simulator used to do the boat simulations (step, etc.).</li>
<li><strong>destination</strong> (<em>list</em>) – Position [lat, lon] of the wanted destination.</li>
<li><strong>TimeMax</strong> (<em>float</em>) – Time horizon of the search.</li>
<li><strong>TimeMin</strong> (<em>float</em>) – Minimum time to arrive to the destination, computed on several boats which go straight     from the initial point to the destination.</li>
<li><strong>depth</strong> (<em>int</em>) – Maximum depth of the tree.</li>
<li><strong>Nodes</strong> (<em>list</em>) – List of <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a>, representing the tree.</li>
<li><strong>buffer</strong> (<em>list</em>) – The buffer is a list of updates to be included in the master Tree.     One update is a list : [scenarioId, newNodeHash, parentHash, action, reward].</li>
<li><strong>numScenarios</strong> (<em>int</em>) – Number total of scenarios used during the MCT parallel search.</li>
<li><strong>probability</strong> (<em>numpy.array</em>) – array containing the probability of each scenario.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="worker.Tree.best_child">
<code class="descname">best_child</code><span class="sig-paren">(</span><em>node</em>, <em>Master_nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.best_child" title="Permalink to this definition">¶</a></dt>
<dd><p>Select the best child of a node, by comparing their uct values. The comparison is based on the value of the         child in this tree, but also in the master tree, if it exists there.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> (<a class="reference internal" href="#worker.Node" title="worker.Node"><em>worker.Node</em></a>) – The parent node.</li>
<li><strong>Master_nodes</strong> (<em>dict</em>) – <a class="reference external" href="https://docs.python.org/2/library/multiprocessing.html#sharing-state-between-processes">Manager</a> which saves the nodes of every scenario.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The best <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a> of the node given in parameter.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="worker.Tree.default_policy">
<code class="descname">default_policy</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.default_policy" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="worker.Tree.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a> from a node (its parent). The new node is selected randomly         between the available actions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>node</strong> (<a class="reference internal" href="#worker.Node" title="worker.Node"><em>worker.Node</em></a>) – The parent node.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">The new <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="worker.Tree.get_master_uct">
<code class="descname">get_master_uct</code><span class="sig-paren">(</span><em>node_hash</em>, <em>Master_nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.get_master_uct" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the uct value seen by the master tree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node_hash</strong> (<em>int</em>) – the corresponding hash node.</li>
<li><strong>Master_nodes</strong> (<em>dict</em>) – dictionary of MasterNode objects.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Return float:</th><td class="field-body"><p class="first last">The uct value of the corresponding node passed in parameter.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="worker.Tree.get_sim_to_estimate_state">
<code class="descname">get_sim_to_estimate_state</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.get_sim_to_estimate_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="worker.Tree.integrate_buffer">
<code class="descname">integrate_buffer</code><span class="sig-paren">(</span><em>Master_nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.integrate_buffer" title="Permalink to this definition">¶</a></dt>
<dd><p>Integrates the buffer of update from this scenario. The buffer is a list of updates coming from the worker.         One update is a list : [scenarioId, newNodeHash, parentHash, action, reward]</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>Master_nodes</strong> (<em>dict</em>) – dictionary of MasterNode objects.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="worker.Tree.is_node_terminal">
<code class="descname">is_node_terminal</code><span class="sig-paren">(</span><em>node</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.is_node_terminal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="worker.Tree.is_state_at_dest">
<em class="property">static </em><code class="descname">is_state_at_dest</code><span class="sig-paren">(</span><em>destination</em>, <em>stateA</em>, <em>stateB</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.is_state_at_dest" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="worker.Tree.is_state_terminal">
<em class="property">static </em><code class="descname">is_state_terminal</code><span class="sig-paren">(</span><em>simulator</em>, <em>state</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.is_state_terminal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="worker.Tree.tree_policy">
<code class="descname">tree_policy</code><span class="sig-paren">(</span><em>node</em>, <em>master_nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.tree_policy" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the policy to know from which node will be expanded during the next iteration,         the policy starts from a specific node.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>node</strong> – starting node of the tree policy, usually the root node.</li>
<li><strong>Master_nodes</strong> (<em>dict</em>) – <p><a class="reference external" href="https://docs.python.org/2/library/multiprocessing.html#sharing-state-between-processes">Manager</a> which saves the nodes of every scenario.</p>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">The expanded <a class="reference internal" href="#worker.Node" title="worker.Node"><code class="xref py py-class docutils literal"><span class="pre">worker.Node</span></code></a>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="worker.Tree.uct_search">
<code class="descname">uct_search</code><span class="sig-paren">(</span><em>rootState</em>, <em>frequency</em>, <em>Master_nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#worker.Tree.uct_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Launches the MCTS for the scenario.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>rootState</strong> (<em>list</em>) – Initial state [time, lat, lon].</li>
<li><strong>frequency</strong> (<em>int</em>) – Length of the buffer: number of iterations between each buffer integrations.</li>
<li><strong>Master_nodes</strong> (<em>dict</em>) – <p><a class="reference external" href="https://docs.python.org/2/library/multiprocessing.html#sharing-state-between-processes">Manager</a> which saves the nodes of every scenario.</p>
</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-forest">
<span id="forest"></span><h2>forest<a class="headerlink" href="#module-forest" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="forest.Forest">
<em class="property">class </em><code class="descclassname">forest.</code><code class="descname">Forest</code><span class="sig-paren">(</span><em>listsimulators=[]</em>, <em>destination=[]</em>, <em>timemin=0</em>, <em>budget=100</em><span class="sig-paren">)</span><a class="headerlink" href="#forest.Forest" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Object coordinating a MasterTree and its WorkerTrees during a parallel MCTS search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>listsimulators</strong> (<em>list</em>) – a list of <a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><code class="xref py py-class docutils literal"><span class="pre">simulatorTLKT.Simulator</span></code></a> objects, each simulator should correspond to a different weather scenario</li>
<li><strong>destination</strong> (<em>list</em><em>(</em><em>float</em><em>,</em><em>float</em><em>)</em>) – [lat,lon], destination to reach</li>
<li><strong>timemin</strong> (<em>float</em>) – reference time to define the reward model, comes from the <a class="reference internal" href="#forest.initialize_simulators" title="forest.initialize_simulators"><code class="xref py py-func docutils literal"><span class="pre">initialize_simulators()</span></code></a> function</li>
<li><strong>budget</strong> (<em>int</em>) – number of nodes in each worker at the end of the search</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="forest.Forest.launch_search">
<code class="descname">launch_search</code><span class="sig-paren">(</span><em>root_state</em>, <em>frequency</em><span class="sig-paren">)</span><a class="headerlink" href="#forest.Forest.launch_search" title="Permalink to this definition">¶</a></dt>
<dd><p>Launches a parallel MCTS search. It uses multiprocessing class. Each worker is a <code class="xref py py-class docutils literal"><span class="pre">multiprocessing.Process</span></code>
object. The master is a <code class="xref py py-class docutils literal"><span class="pre">multiprocessing.Manager</span></code> hosting a dict() (called Master_nodes)
that can be read and written into by each worker.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>root_state</strong> (<em>list</em><em>(</em><em>int</em><em>,</em><em>float</em><em>,</em><em>float</em><em>)</em>) – [time index, lat, lon], state of the root node of the sea</li>
<li><strong>frequency</strong> (<em>int</em>) – number of node that are expanded in a worker before this one updates the corresponding nodes in the master.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">dictionnary of <a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">master_node.MasterNode</span></code></a> the keys are the nodes’ hashes. These results must be
deep copied with <a class="reference internal" href="#master_node.deepcopy_dict" title="master_node.deepcopy_dict"><code class="xref py py-func docutils literal"><span class="pre">master_node.deepcopy_dict()</span></code></a> if you want to do anything with them.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last"><code class="xref py py-class docutils literal"><span class="pre">multiprocessing.Manager.dict</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="forest.create_simulators">
<code class="descclassname">forest.</code><code class="descname">create_simulators</code><span class="sig-paren">(</span><em>weathers</em>, <em>numberofsim</em>, <em>simtimestep=6</em>, <em>stateinit=(0</em>, <em>47.5</em>, <em>356.5)</em>, <em>ndaysim=8</em>, <em>deltalatlon=0.5</em><span class="sig-paren">)</span><a class="headerlink" href="#forest.create_simulators" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates and returns a list of <a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><code class="xref py py-class docutils literal"><span class="pre">simulatorTLKT.Simulator</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>weathers</strong> (<em>list</em><em>(</em><em>)</em>) – List of <a class="reference internal" href="model.html#weatherTLKT.Weather" title="weatherTLKT.Weather"><code class="xref py py-class docutils literal"><span class="pre">weatherTLKT.Weather</span></code></a> objects, each one is the wind scenario of the
<a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><code class="xref py py-class docutils literal"><span class="pre">simulatorTLKT.Simulator</span></code></a> object to be created</li>
<li><strong>numberofsim</strong> (<em>int</em>) – number of simulator we want to create. Must be lower or equal to len(weathers). The simulators
are created by chronologically browsing the weathers list</li>
<li><strong>simtimestep</strong> (<em>float</em>) – time step in hours of the simulator</li>
<li><strong>stateinit</strong> (<em>list</em><em>(</em><em>int</em><em>,</em><em>float</em><em>,</em><em>float</em><em>)</em>) – [t_index, lat, lon], initial state of the simulators</li>
<li><strong>ndaysim</strong> (<em>int</em>) – time horizon of the search. Must be smaller or equal to the weather object time horizon.</li>
<li><strong>deltalatlon</strong> (<em>float</em>) – latitude and longitude discretization of the simulators. Just for plotting purposes</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">List of <a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><code class="xref py py-class docutils literal"><span class="pre">simulatorTLKT.Simulator</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list()</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="forest.download_scenarios">
<code class="descclassname">forest.</code><code class="descname">download_scenarios</code><span class="sig-paren">(</span><em>mydate, latBound=[43, 50], lonBound=[350, 360], website='http://nomads.ncep.noaa.gov:9090/dods/', scenario_ids=range(1, 21)</em><span class="sig-paren">)</span><a class="headerlink" href="#forest.download_scenarios" title="Permalink to this definition">¶</a></dt>
<dd><p>To download the weathers scenarios for a MCTS ** /!: needs to be launched in the terminal**.
Scenarios are saved as ‘../data/’ + mydate + ‘_gep_’ + s_id + ‘00z.obj’ where s_id is the scenario id. They are
stored as <a class="reference internal" href="model.html#weatherTLKT.Weather" title="weatherTLKT.Weather"><code class="xref py py-class docutils literal"><span class="pre">weatherTLKT.Weather</span></code></a> objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>mydate</strong> (<em>string</em>) – ‘yyyymmdd’ date of the day starting the weather forecast in US format</li>
<li><strong>latBound</strong> (<em>list</em><em>(</em><em>float</em><em>,</em><em>float</em><em>)</em>) – [latmin, latmax], latitude boundaries of the domain on which the forecast is desired</li>
<li><strong>lonBound</strong> (<em>list</em><em>(</em><em>float</em><em>,</em><em>float</em><em>)</em>) – [lonmin, lonmax], longitude boundaries of the domain on which the forecast is desired</li>
<li><strong>website</strong> (<em>string</em>) – url of the server hosting the forecasts</li>
<li><strong>scenario_ids</strong> (<em>range</em>) – range covering the forecasts scenarios we want to download</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="forest.initialize_simulators">
<code class="descclassname">forest.</code><code class="descname">initialize_simulators</code><span class="sig-paren">(</span><em>sims</em>, <em>ntra</em>, <em>stateinit</em>, <em>missionheading</em>, <em>plot=False</em><span class="sig-paren">)</span><a class="headerlink" href="#forest.initialize_simulators" title="Permalink to this definition">¶</a></dt>
<dd><p>Find the destination point and the reference time for a list of simulators. These quantities are mandatory in order
to carry out a MCTS parallel search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>sims</strong> (<em>list</em><em>(</em><em>)</em>) – List of <a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><code class="xref py py-class docutils literal"><span class="pre">simulatorTLKT.Simulator</span></code></a></li>
<li><strong>ntra</strong> (<em>int</em>) – Number of trajectories used to estimate the initialization</li>
<li><strong>stateinit</strong> (<em>list</em><em>(</em><em>int</em><em>,</em><em>float</em><em>,</em><em>float</em><em>)</em>) – t_index, lat, lon], starting point of the MCTS search</li>
<li><strong>missionheading</strong> (<em>float</em>) – angle in deg wrt true North of the desired destination from stateinit</li>
<li><strong>plot</strong> (<em>bool</em>) – if True displays the initialization trajectories</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">[destination, timemin], destination are the coordinates of the destination point and timemin is in days</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list(list(float,float), float)</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="forest.load_scenarios">
<code class="descclassname">forest.</code><code class="descname">load_scenarios</code><span class="sig-paren">(</span><em>mydate, scenario_ids=range(1, 21), latBound=[-90, 90], lonBound=[0, 360], timeSteps=[0, 64]</em><span class="sig-paren">)</span><a class="headerlink" href="#forest.load_scenarios" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads previously downloaded scenarios and returns the corresponding list of <a class="reference internal" href="model.html#weatherTLKT.Weather" title="weatherTLKT.Weather"><code class="xref py py-class docutils literal"><span class="pre">weatherTLKT.Weather</span></code></a> objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mydate</strong> (<em>string</em>) – ‘yyyymmdd’ date of the day starting the weather forecast in US format</li>
<li><strong>scenario_ids</strong> – range covering the forecasts scenarios we want to download</li>
<li><strong>latBound</strong> (<em>list</em><em>(</em><em>float</em><em>,</em><em>float</em><em>)</em>) – [latmin, latmax], latitude boundaries of the domain on which the forecast is desired.
If smaller than domain of stored object, returns a cropped object.
Returns stored object otherwise</li>
<li><strong>lonBound</strong> (<em>list</em><em>(</em><em>float</em><em>,</em><em>float</em><em>)</em>) – [lonmin, lonmax], longitude boundaries of the domain on which the forecast is desired.
If smaller than domain of stored object, returns a cropped object.
Returns stored object otherwise</li>
<li><strong>timeSteps</strong> (<em>list</em><em>(</em><em>int</em><em>,</em><em>int</em><em>)</em>) – [min_t_index, max_t_index], time span of the desired forecast.
If smaller than domain of stored object, returns a cropped object.
Returns stored object otherwise</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">List of of <a class="reference internal" href="model.html#weatherTLKT.Weather" title="weatherTLKT.Weather"><code class="xref py py-class docutils literal"><span class="pre">weatherTLKT.Weather</span></code></a></p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body"><p class="first last">list()</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="forest.play_multiple_scenarios">
<code class="descclassname">forest.</code><code class="descname">play_multiple_scenarios</code><span class="sig-paren">(</span><em>sims</em><span class="sig-paren">)</span><a class="headerlink" href="#forest.play_multiple_scenarios" title="Permalink to this definition">¶</a></dt>
<dd><p>Display an interactive representation of the wind conditions of a list of <a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><code class="xref py py-class docutils literal"><span class="pre">simulatorTLKT.Simulator</span></code></a> objects.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>sims</strong> (<em>list</em><em>(</em><em>)</em>) – List of the <a class="reference internal" href="model.html#simulatorTLKT.Simulator" title="simulatorTLKT.Simulator"><code class="xref py py-class docutils literal"><span class="pre">simulatorTLKT.Simulator</span></code></a> objects</td>
</tr>
</tbody>
</table>
</dd></dl>

<p>Basic use example of the forest class:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">forest</span> <span class="k">as</span> <span class="nn">ft</span>
<span class="kn">from</span> <span class="nn">master_node</span> <span class="k">import</span> <span class="n">deepcopy_dict</span>
<span class="kn">from</span> <span class="nn">master</span> <span class="k">import</span> <span class="n">MasterTree</span>

<span class="c1"># Scenario parameters</span>
<span class="n">date</span> <span class="o">=</span> <span class="s1">&#39;20180223&#39;</span>  <span class="c1"># January 30, 2018</span>
<span class="n">latBounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">40</span><span class="p">,</span> <span class="mi">50</span><span class="p">]</span>
<span class="n">lonBounds</span> <span class="o">=</span> <span class="p">[</span><span class="mi">360</span> <span class="o">-</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">360</span><span class="p">]</span>

<span class="c1">## Download and saves the 5 scenarios</span>
<span class="c1">## run this in a terminal if you actually want to download anything</span>
<span class="c1"># ft.download_scenarios(date, latBound=latBounds, lonBound=lonBounds, scenario_ids=range(1, 5))</span>

<span class="c1"># Load the weathers scnearios</span>
<span class="n">Weathers</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">load_scenarios</span><span class="p">(</span><span class="n">date</span><span class="p">,</span> <span class="n">latBound</span><span class="o">=</span><span class="n">latBounds</span><span class="p">,</span> <span class="n">lonBound</span><span class="o">=</span><span class="n">lonBounds</span><span class="p">,</span> <span class="n">scenario_ids</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>

<span class="c1"># Simulators parameters</span>
<span class="n">NUMBER_OF_SIM</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># &lt;=20</span>
<span class="n">SIM_TIME_STEP</span> <span class="o">=</span> <span class="mi">6</span>  <span class="c1"># in hours</span>
<span class="n">STATE_INIT</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mf">42.5</span><span class="p">,</span> <span class="mi">360</span> <span class="o">-</span> <span class="mf">11.5</span><span class="p">]</span>  <span class="c1"># first state</span>
<span class="n">N_DAYS_SIM</span> <span class="o">=</span> <span class="mi">4</span>  <span class="c1"># time horizon in days</span>
<span class="n">missionheading</span> <span class="o">=</span> <span class="mi">0</span>
<span class="n">n_trajectories</span> <span class="o">=</span> <span class="mi">50</span>

<span class="c1"># Create the simulators</span>
<span class="n">sims</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">create_simulators</span><span class="p">(</span><span class="n">Weathers</span><span class="p">,</span> <span class="n">numberofsim</span><span class="o">=</span><span class="n">NUMBER_OF_SIM</span><span class="p">,</span> <span class="n">simtimestep</span><span class="o">=</span><span class="n">SIM_TIME_STEP</span><span class="p">,</span>
                            <span class="n">stateinit</span><span class="o">=</span><span class="n">STATE_INIT</span><span class="p">,</span> <span class="n">ndaysim</span><span class="o">=</span><span class="n">N_DAYS_SIM</span><span class="p">)</span>

<span class="c1"># Initialize the simulators to get common destination and individual time min</span>
<span class="n">destination</span><span class="p">,</span> <span class="n">timemin</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">initialize_simulators</span><span class="p">(</span><span class="n">sims</span><span class="p">,</span> <span class="n">n_trajectories</span><span class="p">,</span> <span class="n">STATE_INIT</span><span class="p">,</span> <span class="n">missionheading</span><span class="p">,</span> <span class="n">plot</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s2">&quot;destination : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;  &amp;  timemin : &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">timemin</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

<span class="c1"># Search parameters</span>
<span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;tree_exemple&quot;</span>
<span class="n">frequency</span> <span class="o">=</span> <span class="mi">10</span>
<span class="n">budget</span> <span class="o">=</span> <span class="mi">100</span>

<span class="c1"># Initialize the forest</span>
<span class="n">forest</span> <span class="o">=</span> <span class="n">ft</span><span class="o">.</span><span class="n">Forest</span><span class="p">(</span><span class="n">listsimulators</span><span class="o">=</span><span class="n">sims</span><span class="p">,</span> <span class="n">destination</span><span class="o">=</span><span class="n">destination</span><span class="p">,</span> <span class="n">timemin</span><span class="o">=</span><span class="n">timemin</span><span class="p">,</span> <span class="n">budget</span><span class="o">=</span><span class="n">budget</span><span class="p">)</span>

<span class="c1"># Launch the search</span>
<span class="n">master_nodes</span> <span class="o">=</span> <span class="n">forest</span><span class="o">.</span><span class="n">launch_search</span><span class="p">(</span><span class="n">STATE_INIT</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span>

<span class="c1"># Save the result as a tree</span>
<span class="n">new_dict</span> <span class="o">=</span> <span class="n">deepcopy_dict</span><span class="p">(</span><span class="n">master_nodes</span><span class="p">)</span>
<span class="n">forest</span><span class="o">.</span><span class="n">master</span> <span class="o">=</span> <span class="n">MasterTree</span><span class="p">(</span><span class="n">sims</span><span class="p">,</span> <span class="n">destination</span><span class="p">,</span> <span class="n">nodes</span><span class="o">=</span><span class="n">new_dict</span><span class="p">)</span>
<span class="n">forest</span><span class="o">.</span><span class="n">master</span><span class="o">.</span><span class="n">save_tree</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<span class="c1"># Displays some juicy results</span>
<span class="n">forest</span><span class="o">.</span><span class="n">master</span><span class="o">.</span><span class="n">plot_tree_uct</span><span class="p">()</span>
<span class="n">forest</span><span class="o">.</span><span class="n">master</span><span class="o">.</span><span class="n">get_best_policy</span><span class="p">()</span>
<span class="n">forest</span><span class="o">.</span><span class="n">master</span><span class="o">.</span><span class="n">plot_best_policy</span><span class="p">()</span>
<span class="n">forest</span><span class="o">.</span><span class="n">master</span><span class="o">.</span><span class="n">plot_hist_best_policy</span><span class="p">(</span><span class="n">interactive</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="module-master_node">
<span id="master-node"></span><h2>master_node<a class="headerlink" href="#module-master_node" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="master_node.MasterNode">
<em class="property">class </em><code class="descclassname">master_node.</code><code class="descname">MasterNode</code><span class="sig-paren">(</span><em>numscenarios</em>, <em>nodehash=None</em>, <em>parentNode=None</em>, <em>action=None</em>, <em>rewards=[]</em><span class="sig-paren">)</span><a class="headerlink" href="#master_node.MasterNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Node of a MasterTree.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Variables:</th><td class="field-body"><ul class="first last simple">
<li><strong>hash</strong> (<em>int</em>) – hash of the node (key of the dictionary <code class="xref py py-attr docutils literal"><span class="pre">MasterTree.nodes</span></code>)</li>
<li><strong>arm</strong> (<em>int</em>) – Action taken to get to this node from its parent.</li>
<li><strong>parentNode</strong> (<a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><em>MasterNode</em></a>) – parent of this node</li>
<li><strong>rewards</strong> (<em>numpy.array</em>) – Array of <cite>Hist</cite>. Its shape is (#scenario, #possible actions).</li>
<li><strong>children</strong> (<em>list</em>) – List of children (<a class="reference internal" href="#master_node.MasterNode" title="master_node.MasterNode"><code class="xref py py-class docutils literal"><span class="pre">MasterNode</span></code></a>)</li>
<li><strong>depth</strong> (<em>int</em>) – Depth of the node.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="master_node.MasterNode.add_reward">
<code class="descname">add_reward</code><span class="sig-paren">(</span><em>idscenario</em>, <em>reward</em><span class="sig-paren">)</span><a class="headerlink" href="#master_node.MasterNode.add_reward" title="Permalink to this definition">¶</a></dt>
<dd><p>Includes a reward into the histogram for a random action of one scenario.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>idscenario</strong> (<em>int</em>) – id of the scenario/workertree from which the update is coming.</li>
<li><strong>reward</strong> (<em>float</em>) – reward of the update.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master_node.MasterNode.add_reward_action">
<code class="descname">add_reward_action</code><span class="sig-paren">(</span><em>idscenario</em>, <em>action</em>, <em>reward</em><span class="sig-paren">)</span><a class="headerlink" href="#master_node.MasterNode.add_reward_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Includes a reward into the histogram for one action of one scenario.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>idscenario</strong> (<em>int</em>) – id of the scenario/workertree from which the update is coming.</li>
<li><strong>action</strong> (<em>int</em>) – Action (in degree) of the update</li>
<li><strong>reward</strong> (<em>float</em>) – reward of the update</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="master_node.MasterNode.is_expanded">
<code class="descname">is_expanded</code><span class="sig-paren">(</span><em>idscenario</em><span class="sig-paren">)</span><a class="headerlink" href="#master_node.MasterNode.is_expanded" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if this node has been expanded by a scenario.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>idscenario</strong> – id of the scenario</td>
</tr>
<tr class="field-even field"><th class="field-name">Return boolean:</th><td class="field-body">True if the scenario has expanded this node.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="master_node.deepcopy_dict">
<code class="descclassname">master_node.</code><code class="descname">deepcopy_dict</code><span class="sig-paren">(</span><em>nodes</em><span class="sig-paren">)</span><a class="headerlink" href="#master_node.deepcopy_dict" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a deep copy of a MasterNode dictionary.
Add also the children, the parentNode and the depth of each node.
This method is called after the search before saving the result.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nodes</strong> (<em>dict</em>) – a dictionary with MasterNode object</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">the deep copy of the input dictionary</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="index.html">
              <img class="logo" src="_static/IBOAT_logo1.png" alt="Logo"/>
            </a></p>
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">Package solver</a><ul>
<li><a class="reference internal" href="#module-master">master</a></li>
<li><a class="reference internal" href="#module-worker">worker</a></li>
<li><a class="reference internal" href="#module-forest">forest</a></li>
<li><a class="reference internal" href="#module-master_node">master_node</a></li>
</ul>
</li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="model.html" title="previous chapter">Package model</a></li>
      <li>Next: <a href="isochrones.html" title="next chapter">Package isochrones</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/solver.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Fabien Brulport, Paul Barde, Jean-Michel Bellay.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.3</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/solver.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>